<?php

namespace App\Services;

use App\Models\User;
use App\Models\Schedule;
use App\Models\Availability;
use Illuminate\Support\Facades\Log;
use Google_Client;
use Google_Service_Calendar;
use Google_Service_Calendar_Event;
use Google_Service_Calendar_EventDateTime;
use Google_Service_Calendar_ConferenceData;
use Google_Service_Calendar_CreateConferenceRequest;
use Google_Service_Calendar_ConferenceSolutionKey;
use Google_Service_Calendar_FreeBusyRequest;
use Exception;
use Carbon\Carbon;

/**
 * Google Calendar Service
 * 
 * Handles Google Calendar event creation and management
 * 
 * @package     Laravel CMS App
 * @subpackage  Services
 * @category    Google Calendar Integration
 * @author      Go Globe CMS Team
 * @since       1.0.0
 */
class GoogleCalendarService
{
    /**
     * Google Client instance
     * 
     * @var Google_Client
     */
    private $googleClient;

    /**
     * Constructor
     */
    public function __construct()
    {
        $this->googleClient = new Google_Client();
        $this->googleClient->setClientId(env('GOOGLE_CLIENT_ID'));
        $this->googleClient->setClientSecret(env('GOOGLE_CLIENT_SECRET'));
        $this->googleClient->addScope(Google_Service_Calendar::CALENDAR);
    }

    /**
     * Create Google Calendar event with Meet link
     * 
     * @param Schedule $schedule
     * @return array
     * @throws Exception
     */
    public function createCalendarEvent(Schedule $schedule): array
    {
        try {
            $trainer = $schedule->trainer;
            $client = $schedule->client;

            // Check if trainer has Google token
            if (!$trainer->google_token) {
                throw new Exception('Trainer not connected to Google Calendar');
            }

            // Set access token
            $this->googleClient->setAccessToken($trainer->google_token);

            // Check if token is expired and refresh if needed
            if ($this->googleClient->isAccessTokenExpired()) {
                if ($this->googleClient->getRefreshToken()) {
                    $newToken = $this->googleClient->fetchAccessTokenWithRefreshToken();
                    if (isset($newToken['error'])) {
                        throw new Exception('Failed to refresh Google access token');
                    }
                    $trainer->google_token = $newToken;
                    $trainer->save();
                } else {
                    throw new Exception('Google access token expired and no refresh token available');
                }
            }

            // Create Calendar service
            $calendarService = new Google_Service_Calendar($this->googleClient);

            // Create event
            $event = new Google_Service_Calendar_Event();
            
            // Set event title - use meeting agenda if available, otherwise default title
            $eventTitle = !empty($schedule->meeting_agenda) 
                ? $schedule->meeting_agenda 
                : "Training Session - {$client->name}";
            $event->setSummary($eventTitle);
            
            // Set event description
            $description = "Training session between {$trainer->name} (Trainer) and {$client->name} (Client).\n\n";
            $description .= "Session Details:\n";
            $description .= "- Date: {$schedule->date->format('F j, Y')}\n";
            $description .= "- Time: {$schedule->start_time->format('g:i A')} - {$schedule->end_time->format('g:i A')}\n";
            if ($schedule->notes) {
                $description .= "- Notes: {$schedule->notes}\n";
            }
            $description .= "\nGenerated by Go Globe CMS Training Platform";
            $event->setDescription($description);

            // Set start time
            $startDateTime = new Google_Service_Calendar_EventDateTime();
            $startDateTime->setDateTime($schedule->date->format('Y-m-d') . 'T' . $schedule->start_time->format('H:i:s'));
            $startDateTime->setTimeZone($trainer->timezone ?? 'UTC');
            $event->setStart($startDateTime);

            // Set end time
            $endDateTime = new Google_Service_Calendar_EventDateTime();
            $endDateTime->setDateTime($schedule->date->format('Y-m-d') . 'T' . $schedule->end_time->format('H:i:s'));
            $endDateTime->setTimeZone($trainer->timezone ?? 'UTC');
            $event->setEnd($endDateTime);

            // Add attendees
            $attendees = [
                ['email' => $trainer->email, 'displayName' => $trainer->name],
                ['email' => $client->email, 'displayName' => $client->name]
            ];
            $event->setAttendees($attendees);

            // Create Google Meet conference
            $conferenceData = new Google_Service_Calendar_ConferenceData();
            $createRequest = new Google_Service_Calendar_CreateConferenceRequest();
            $createRequest->setRequestId(uniqid());
            
            $solutionKey = new Google_Service_Calendar_ConferenceSolutionKey();
            $solutionKey->setType('hangoutsMeet');
            $createRequest->setConferenceSolutionKey($solutionKey);
            
            $conferenceData->setCreateRequest($createRequest);
            $event->setConferenceData($conferenceData);

            // Set event visibility and other properties
            $event->setVisibility('private');
            $event->setStatus('confirmed');

            // Insert event into calendar
            $createdEvent = $calendarService->events->insert('primary', $event, [
                'conferenceDataVersion' => 1,
                'sendUpdates' => 'all'
            ]);

            // Extract Meet link
            $meetLink = null;
            if ($createdEvent->getConferenceData() && $createdEvent->getConferenceData()->getEntryPoints()) {
                foreach ($createdEvent->getConferenceData()->getEntryPoints() as $entryPoint) {
                    if ($entryPoint->getEntryPointType() === 'video') {
                        $meetLink = $entryPoint->getUri();
                        break;
                    }
                }
            }

            // Update schedule with Google event details
            $schedule->google_event_id = $createdEvent->getId();
            $schedule->meet_link = $meetLink;
            $schedule->save();

            Log::info('Google Calendar event created', [
                'schedule_id' => $schedule->id,
                'event_id' => $createdEvent->getId(),
                'trainer_id' => $trainer->id,
                'client_id' => $client->id
            ]);

            return [
                'success' => true,
                'event_id' => $createdEvent->getId(),
                'meet_link' => $meetLink,
                'event_url' => $createdEvent->getHtmlLink()
            ];

        } catch (Exception $e) {
            Log::error('Failed to create Google Calendar event', [
                'schedule_id' => $schedule->id,
                'error' => $e->getMessage(),
                'trainer_id' => $schedule->trainer_id
            ]);

            throw new Exception('Failed to create Google Calendar event: ' . $e->getMessage());
        }
    }

    /**
     * Update Google Calendar event
     * 
     * @param Schedule $schedule
     * @return array
     * @throws Exception
     */
    public function updateCalendarEvent(Schedule $schedule): array
    {
        try {
            $trainer = $schedule->trainer;

            if (!$trainer->google_token || !$schedule->google_event_id) {
                throw new Exception('No Google Calendar event to update');
            }

            // Set access token
            $this->googleClient->setAccessToken($trainer->google_token);

            // Check if token is expired and refresh if needed
            if ($this->googleClient->isAccessTokenExpired()) {
                if ($this->googleClient->getRefreshToken()) {
                    $newToken = $this->googleClient->fetchAccessTokenWithRefreshToken();
                    if (isset($newToken['error'])) {
                        throw new Exception('Failed to refresh Google access token');
                    }
                    $trainer->google_token = $newToken;
                    $trainer->save();
                } else {
                    throw new Exception('Google access token expired and no refresh token available');
                }
            }

            // Create Calendar service
            $calendarService = new Google_Service_Calendar($this->googleClient);

            // Get existing event
            $event = $calendarService->events->get('primary', $schedule->google_event_id);

            // Update event details
            $client = $schedule->client;
            // Use meeting agenda if available, otherwise default title
            $eventTitle = !empty($schedule->meeting_agenda) 
                ? $schedule->meeting_agenda 
                : "Training Session - {$client->name}";
            $event->setSummary($eventTitle);
            
            $description = "Training session between {$trainer->name} (Trainer) and {$client->name} (Client).\n\n";
            $description .= "Session Details:\n";
            $description .= "- Date: {$schedule->date->format('F j, Y')}\n";
            $description .= "- Time: {$schedule->start_time->format('g:i A')} - {$schedule->end_time->format('g:i A')}\n";
            if ($schedule->notes) {
                $description .= "- Notes: {$schedule->notes}\n";
            }
            $description .= "\nGenerated by Go Globe CMS Training Platform";
            $event->setDescription($description);

            // Update start time
            $startDateTime = new Google_Service_Calendar_EventDateTime();
            $startDateTime->setDateTime($schedule->date->format('Y-m-d') . 'T' . $schedule->start_time->format('H:i:s'));
            $startDateTime->setTimeZone($trainer->timezone ?? 'UTC');
            $event->setStart($startDateTime);

            // Update end time
            $endDateTime = new Google_Service_Calendar_EventDateTime();
            $endDateTime->setDateTime($schedule->date->format('Y-m-d') . 'T' . $schedule->end_time->format('H:i:s'));
            $endDateTime->setTimeZone($trainer->timezone ?? 'UTC');
            $event->setEnd($endDateTime);

            // Update the event
            $updatedEvent = $calendarService->events->update('primary', $schedule->google_event_id, $event, [
                'sendUpdates' => 'all'
            ]);

            Log::info('Google Calendar event updated', [
                'schedule_id' => $schedule->id,
                'event_id' => $schedule->google_event_id,
                'trainer_id' => $trainer->id
            ]);

            return [
                'success' => true,
                'event_id' => $updatedEvent->getId(),
                'meet_link' => $schedule->meet_link,
                'event_url' => $updatedEvent->getHtmlLink()
            ];

        } catch (Exception $e) {
            Log::error('Failed to update Google Calendar event', [
                'schedule_id' => $schedule->id,
                'event_id' => $schedule->google_event_id,
                'error' => $e->getMessage()
            ]);

            throw new Exception('Failed to update Google Calendar event: ' . $e->getMessage());
        }
    }

    /**
     * Delete Google Calendar event
     * 
     * @param Schedule $schedule
     * @return bool
     */
    public function deleteCalendarEvent(Schedule $schedule): bool
    {
        try {
            $trainer = $schedule->trainer;

            if (!$trainer->google_token || !$schedule->google_event_id) {
                return true; // Nothing to delete
            }

            // Set access token
            $this->googleClient->setAccessToken($trainer->google_token);

            // Check if token is expired and refresh if needed
            if ($this->googleClient->isAccessTokenExpired()) {
                if ($this->googleClient->getRefreshToken()) {
                    $newToken = $this->googleClient->fetchAccessTokenWithRefreshToken();
                    if (isset($newToken['error'])) {
                        Log::warning('Failed to refresh token for event deletion', [
                            'schedule_id' => $schedule->id,
                            'trainer_id' => $trainer->id
                        ]);
                        return false;
                    }
                    $trainer->google_token = $newToken;
                    $trainer->save();
                } else {
                    Log::warning('No refresh token available for event deletion', [
                        'schedule_id' => $schedule->id,
                        'trainer_id' => $trainer->id
                    ]);
                    return false;
                }
            }

            // Create Calendar service
            $calendarService = new Google_Service_Calendar($this->googleClient);

            // Delete the event
            $calendarService->events->delete('primary', $schedule->google_event_id, [
                'sendUpdates' => 'all'
            ]);

            Log::info('Google Calendar event deleted', [
                'schedule_id' => $schedule->id,
                'event_id' => $schedule->google_event_id,
                'trainer_id' => $trainer->id
            ]);

            return true;

        } catch (Exception $e) {
            Log::error('Failed to delete Google Calendar event', [
                'schedule_id' => $schedule->id,
                'event_id' => $schedule->google_event_id,
                'error' => $e->getMessage()
            ]);

            return false;
        }
    }

    /**
     * Check if trainer is connected to Google Calendar
     * 
     * @param User $trainer
     * @return bool
     */
    public function isTrainerConnected(User $trainer): bool
    {
        if (!$trainer->google_token || $trainer->role !== 'trainer') {
            return false;
        }

        try {
            $this->googleClient->setAccessToken($trainer->google_token);
            
            // If token is expired, try to refresh
            if ($this->googleClient->isAccessTokenExpired()) {
                if ($this->googleClient->getRefreshToken()) {
                    $newToken = $this->googleClient->fetchAccessTokenWithRefreshToken();
                    if (isset($newToken['error'])) {
                        return false;
                    }
                    $trainer->google_token = $newToken;
                    $trainer->save();
                    return true;
                } else {
                    return false;
                }
            }

            return true;

        } catch (Exception $e) {
            Log::warning('Failed to verify trainer Google connection', [
                'trainer_id' => $trainer->id,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * Get available time slots for a trainer from Google Calendar
     * 
     * @param User $trainer
     * @param string $startDate
     * @param string $endDate
     * @return array
     */
    public function getAvailableSlots(User $trainer, string $startDate, string $endDate, int $slotDuration = 60): array
    {
        try {
            if (!$trainer->google_token || $trainer->role !== 'trainer') {
                throw new Exception('Trainer does not have Google Calendar connected');
            }

            // Set access token
            $this->googleClient->setAccessToken($trainer->google_token);

            // Check if token is expired and refresh if needed
            if ($this->googleClient->isAccessTokenExpired()) {
                if ($this->googleClient->getRefreshToken()) {
                    $newToken = $this->googleClient->fetchAccessTokenWithRefreshToken();
                    if (isset($newToken['error'])) {
                        throw new Exception('Failed to refresh Google access token');
                    }
                    $trainer->google_token = $newToken;
                    $trainer->save();
                } else {
                    throw new Exception('Google access token expired and no refresh token available');
                }
            }

            // Get trainer's weekly availability settings
            $weeklyAvailability = Availability::where('trainer_id', $trainer->id)
                ->orderBy('day_of_week')
                ->get()
                ->keyBy('day_of_week');

            if ($weeklyAvailability->isEmpty()) {
                throw new Exception('Trainer has not configured their availability schedule yet');
            }

            // Create Calendar service
            $calendarService = new Google_Service_Calendar($this->googleClient);

            // Set time range
            $timeMin = Carbon::parse($startDate)->startOfDay()->toRfc3339String();
            $timeMax = Carbon::parse($endDate)->endOfDay()->toRfc3339String();

            // Get busy times from Google Calendar
            $freebusy = new Google_Service_Calendar_FreeBusyRequest();
            $freebusy->setTimeMin($timeMin);
            $freebusy->setTimeMax($timeMax);
            $freebusy->setItems([
                ['id' => 'primary']
            ]);

            $freebusyResponse = $calendarService->freebusy->query($freebusy);
            $busyTimes = $freebusyResponse->getCalendars()['primary']->getBusy();

            // Convert busy times to array
            $busySlots = [];
            foreach ($busyTimes as $busyTime) {
                $busySlots[] = [
                    'start' => $busyTime->getStart(),
                    'end' => $busyTime->getEnd()
                ];
            }

            // Generate available slots based on trainer's availability settings
            $availableSlots = [];
            $current = Carbon::parse($startDate);
            $end = Carbon::parse($endDate);

            while ($current->lte($end)) {
                $dayOfWeek = $current->dayOfWeek;
                $dayAvailability = $weeklyAvailability->get($dayOfWeek);

                // Skip if trainer is not available on this day
                if (!$dayAvailability) {
                    $current->addDay();
                    continue;
                }

                $timeRanges = [];

                // Add morning time range if available
                if ($dayAvailability->morning_available && 
                    $dayAvailability->morning_start_time && 
                    $dayAvailability->morning_end_time) {
                    $morningStart = $this->parseTime($dayAvailability->morning_start_time);
                    $morningEnd = $this->parseTime($dayAvailability->morning_end_time);
                    if ($morningStart && $morningEnd) {
                        $timeRanges[] = [
                            'start' => $morningStart,
                            'end' => $morningEnd
                        ];
                    }
                }

                // Add evening time range if available
                if ($dayAvailability->evening_available && 
                    $dayAvailability->evening_start_time && 
                    $dayAvailability->evening_end_time) {
                    $eveningStart = $this->parseTime($dayAvailability->evening_start_time);
                    $eveningEnd = $this->parseTime($dayAvailability->evening_end_time);
                    if ($eveningStart && $eveningEnd) {
                        $timeRanges[] = [
                            'start' => $eveningStart,
                            'end' => $eveningEnd
                        ];
                    }
                }

                // Generate slots for each time range
                foreach ($timeRanges as $timeRange) {
                    $slotStart = $current->copy()->setTime($timeRange['start']->hour, $timeRange['start']->minute, 0);
                    
                    while ($slotStart->lt($current->copy()->setTime($timeRange['end']->hour, $timeRange['end']->minute, 0))) {
                        $slotEnd = $slotStart->copy()->addMinutes($slotDuration);
                        
                        // Make sure slot doesn't exceed the end time
                        $rangeEnd = $current->copy()->setTime($timeRange['end']->hour, $timeRange['end']->minute, 0);
                        if ($slotEnd->gt($rangeEnd)) {
                            break;
                        }

                        // Check if this slot conflicts with busy times
                        $isAvailable = true;
                        foreach ($busySlots as $busySlot) {
                            $busyStart = Carbon::parse($busySlot['start']);
                            $busyEnd = Carbon::parse($busySlot['end']);

                            if ($slotStart->lt($busyEnd) && $slotEnd->gt($busyStart)) {
                                $isAvailable = false;
                                break;
                            }
                        }

                        // Only add slots that are in the future
                        if ($isAvailable && $slotStart->gt(Carbon::now())) {
                            $availableSlots[] = [
                                'start' => $slotStart->toISOString(),
                                'end' => $slotEnd->toISOString(),
                                'start_time' => $slotStart->format('H:i'),
                                'end_time' => $slotEnd->format('H:i'),
                                'date' => $slotStart->format('Y-m-d'),
                                'display' => $slotStart->format('g:i A') . ' - ' . $slotEnd->format('g:i A'),
                                'duration_minutes' => $slotDuration
                            ];
                        }

                        // Move to next slot (add duration + break time if needed)
                        $slotStart->addMinutes($slotDuration);
                    }
                }

                $current->addDay();
            }

            Log::info('Retrieved available slots for trainer', [
                'trainer_id' => $trainer->id,
                'start_date' => $startDate,
                'end_date' => $endDate,
                'slots_count' => count($availableSlots)
            ]);

            return $availableSlots;

        } catch (Exception $e) {
            Log::error('Failed to get available slots', [
                'trainer_id' => $trainer->id,
                'start_date' => $startDate,
                'end_date' => $endDate,
                'error' => $e->getMessage()
            ]);

            throw new Exception('Failed to get available slots: ' . $e->getMessage());
        }
    }

    /**
     * Parse time string to Carbon instance
     * Handles both H:i and H:i:s formats
     */
    private function parseTime($time): ?Carbon
    {
        try {
            // Handle Carbon instances
            if ($time instanceof Carbon) {
                return $time;
            }

            // Handle string formats
            if (is_string($time)) {
                // Try H:i:s format first
                try {
                    return Carbon::createFromFormat('H:i:s', $time);
                } catch (\Exception $e) {
                    // Try H:i format
                    try {
                        return Carbon::createFromFormat('H:i', $time);
                    } catch (\Exception $e2) {
                        // Try parsing as full datetime
                        return Carbon::parse($time);
                    }
                }
            }

            return null;
        } catch (\Exception $e) {
            Log::warning('Failed to parse time', [
                'time' => $time,
                'error' => $e->getMessage()
            ]);
            return null;
        }
    }

    /**
     * Get calendar events for a trainer within a date range
     * 
     * @param User $trainer
     * @param string $startDate
     * @param string $endDate
     * @return array
     * @throws Exception
     */
    public function getCalendarEvents(User $trainer, string $startDate, string $endDate): array
    {
        try {
            if (!$trainer->google_token || $trainer->role !== 'trainer') {
                throw new Exception('Trainer does not have Google Calendar connected');
            }

            // Set access token
            $this->googleClient->setAccessToken($trainer->google_token);

            // Check if token is expired and refresh if needed
            if ($this->googleClient->isAccessTokenExpired()) {
                if ($this->googleClient->getRefreshToken()) {
                    $newToken = $this->googleClient->fetchAccessTokenWithRefreshToken();
                    if (isset($newToken['error'])) {
                        throw new Exception('Failed to refresh Google access token');
                    }
                    $trainer->google_token = $newToken;
                    $trainer->save();
                } else {
                    throw new Exception('Google access token expired and no refresh token available');
                }
            }

            // Create Calendar service
            $calendarService = new Google_Service_Calendar($this->googleClient);

            // Set time range
            $timeMin = \Carbon\Carbon::parse($startDate)->startOfDay()->toRfc3339String();
            $timeMax = \Carbon\Carbon::parse($endDate)->endOfDay()->toRfc3339String();

            // Get events from Google Calendar
            $optParams = [
                'orderBy' => 'startTime',
                'singleEvents' => true,
                'timeMin' => $timeMin,
                'timeMax' => $timeMax,
                'maxResults' => 250
            ];

            $events = $calendarService->events->listEvents('primary', $optParams);
            $eventList = [];

            foreach ($events->getItems() as $event) {
                $start = $event->getStart()->getDateTime() ?: $event->getStart()->getDate();
                $end = $event->getEnd()->getDateTime() ?: $event->getEnd()->getDate();
                
                $eventList[] = [
                    'id' => $event->getId(),
                    'summary' => $event->getSummary(),
                    'description' => $event->getDescription(),
                    'start' => $start,
                    'end' => $end,
                    'location' => $event->getLocation(),
                    'status' => $event->getStatus(),
                    'html_link' => $event->getHtmlLink(),
                    'created' => $event->getCreated(),
                    'updated' => $event->getUpdated()
                ];
            }

            Log::info('Google Calendar events retrieved', [
                'trainer_id' => $trainer->id,
                'event_count' => count($eventList),
                'date_range' => [$startDate, $endDate]
            ]);

            return $eventList;

        } catch (Exception $e) {
            Log::error('Failed to retrieve Google Calendar events', [
                'trainer_id' => $trainer->id,
                'error' => $e->getMessage()
            ]);

            throw new Exception('Failed to retrieve Google Calendar events: ' . $e->getMessage());
        }
    }

    /**
     * Alias for createCalendarEvent method
     * 
     * @param Schedule $schedule
     * @return array
     */
    public function createEvent(Schedule $schedule): array
    {
        return $this->createCalendarEvent($schedule);
    }
}